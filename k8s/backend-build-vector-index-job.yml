# One-off Job: build the markdown vector index into the backend PVC at /data/chroma.
#
# Setup:
#   - PVC is mounted once at /data (no subPath), same as the backend deployment.
#   - Job creates /data/chroma and /data/output if missing (umask 022) then runs
#     python -m backend.scripts.build_markdown_index (venv from PATH, PYTHONPATH=/app).
#   - securityContext: runAsUser 0, runAsGroup 0, allowPrivilegeEscalation false,
#     DAC_READ_SEARCH so the Job can read/write /data. The backend deployment uses
#     the same securityContext so both pods see the same ownership for /data/chroma.
#
# Prerequisites:
#   - Backend ConfigMap and Secret exist (same as for the backend deployment).
#   - PVC urbind-query-mechanism-backend-output exists and is bound.
#   - Backend image contains documents under /app/documents (or override MARKDOWN_DIR
#     and ensure that path is available in the Job).
#
# When to run (avoid concurrent use of the vector store):
#
#   The Job does a full rebuild (reset + bulk write). The backend must not read from
#   the same Chroma path while the Job is writing, or you can get lock errors or
#   inconsistent state. Prefer one of these approaches:
#
#   - Scale the backend to 0, run the Job, then scale back up:
#       kubectl scale deployment urbind-query-mechanism-backend --replicas=0
#       kubectl apply -f k8s/backend-build-vector-index-job.yml
#       kubectl logs job/urbind-query-mechanism-build-vector-index -f
#       kubectl scale deployment urbind-query-mechanism-backend --replicas=1
#
#   - Run the Job right after a new deploy, before enabling VECTOR_STORE_ENABLED
#     (or when vector store is not yet in use).
#
#   - Run during a maintenance window; accept that retrieval may fail or be
#     inconsistent until the Job completes.
#
# How to run:
#
#   1. Apply the Job (creates the Job in the cluster):
#
#        kubectl apply -f k8s/backend-build-vector-index-job.yml
#
#   2. Watch until it completes (or fails):
#
#        kubectl get jobs -l app=urbind-query-mechanism-build-vector-index
#        kubectl logs job/urbind-query-mechanism-build-vector-index -f
#
#   3. On success, the vector store is at /data/chroma (same single /data mount as backend).
#      Restart the backend after: kubectl rollout restart deployment urbind-query-mechanism-backend
#
#   4. If the Job fails, get logs from the (kept) failed pod:
#
#        kubectl get pods -l job-name=urbind-query-mechanism-build-vector-index
#        kubectl logs <pod-name>
#
#   5. To re-run (e.g. after documents or code change), delete the Job and apply again:
#
#        kubectl delete job urbind-query-mechanism-build-vector-index
#        kubectl apply -f k8s/backend-build-vector-index-job.yml
#
# Optional: use a specific namespace:
#
#        kubectl apply -f k8s/backend-build-vector-index-job.yml -n <namespace>
#        kubectl delete job urbind-query-mechanism-build-vector-index -n <namespace>
#
# Inspect from cluster (check manifest in backend pod):
#
#        kubectl exec deployment/urbind-query-mechanism-backend -- ls -la /data/chroma
#        kubectl exec deployment/urbind-query-mechanism-backend -- test -r /data/chroma/index_manifest.json && echo "exists and readable" || echo "missing or not readable"
#
---
apiVersion: batch/v1
kind: Job
metadata:
  name: urbind-query-mechanism-build-vector-index
  namespace: default
  labels:
    app: urbind-query-mechanism-build-vector-index
spec:
  ttlSecondsAfterFinished: 86400
  backoffLimit: 0
  activeDeadlineSeconds: 3600
  template:
    metadata:
      labels:
        app: urbind-query-mechanism-build-vector-index
    spec:
      restartPolicy: Never
      automountServiceAccountToken: false
      containers:
        - name: build-index
          image: ghcr.io/open-earth-foundation/query_mechanism_urbind-backend:dev
          # Match backend deployment securityContext so /data/chroma written here is readable by backend.
          securityContext:
            runAsUser: 0
            runAsGroup: 0
            allowPrivilegeEscalation: false
            capabilities:
              add:
                - DAC_READ_SEARCH
          imagePullPolicy: Always
          envFrom:
            - configMapRef:
                name: urbind-query-mechanism-backend-config
          env:
            - name: PYTHONPATH
              value: /app
            - name: OPENROUTER_API_KEY
              valueFrom:
                secretKeyRef:
                  name: urbind-query-mechanism-backend-secrets
                  key: OPENROUTER_API_KEY
          workingDir: /app
          command:
            - sh
            - -c
            - |
              set -eu
              echo "[job] id:"; id
              echo "[job] python:"; which python || true; python -V

              umask 022
              mkdir -p /data/chroma /data/output

              echo "[job] build index"
              python -m backend.scripts.build_markdown_index --docs-dir /app/documents

              echo "[job] verify manifest"
              ls -la /data/chroma | head -200 || true
              test -r /data/chroma/index_manifest.json
              head -c 200 /data/chroma/index_manifest.json || true
              echo "[job] done"
          volumeMounts:
            - name: output-volume
              mountPath: /data
          resources:
            requests:
              cpu: "500m"
              memory: "2Gi"
            limits:
              cpu: "2000m"
              memory: "4Gi"
      volumes:
        - name: output-volume
          persistentVolumeClaim:
            claimName: urbind-query-mechanism-backend-output